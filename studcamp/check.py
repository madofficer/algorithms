def count_hooks(n, k, ls):
    # Добавляем фиктивный элемент в конец списка, чтобы правильно обработать последний элемент
    ls.append(1)
    # Создаем список hs, содержащий разности между элементами и их следующими элементами в ls, увеличенные на 1
    hs = [ls[i] - ls[i + 1] + 1 for i in range(n)]  

    # Инициализируем переменные
    l, r, s, c = 0, 0, 0, 0

    # Пока правый указатель r меньше длины списка n
    while r < n:
        # Если разность между k и суммой s (длины промежутка) меньше или равна hs[r]
        if k - s <= hs[r]:
            # Если r указывает на последний элемент списка или текущий элемент больше следующего элемента минус k и s
            if r == n - 1 or ls[r] - k + s >= ls[r + 1]:
                # Увеличиваем счетчик на 1
                c += 1
            # Вычитаем длину текущего промежутка из суммы s и передвигаем левый указатель l вправо
            s -= hs[l]
            l += 1
        else:
            # Если условие выше не выполнилось, добавляем длину текущего промежутка к сумме s и передвигаем правый указатель r вправо
            s += hs[r]
            r += 1

    return c

def main():
    # Считываем значения n и k из ввода и преобразуем их в целые числа
    n, k = map(int, input().split())
    # Считываем n значений и добавляем их в список ls
    ls = [int(input()) for _ in range(n)]
    # Вызываем функцию count_hooks и выводим результат
    print(count_hooks(n, k, ls))

if __name__ == "__main__":
    main()
